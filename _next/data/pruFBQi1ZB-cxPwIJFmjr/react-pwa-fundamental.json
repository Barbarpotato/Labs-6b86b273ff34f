{"pageProps":{"article":{"blog_id":"14d690d3-2201-43e4-b936-e06564ab67e2","title":"React PWA Fundamental","short_description":"A Progressive Web App is a type of web application that combines the best features of web and mobile applications. PWAs can be accessed through a web browser but can also be installed on a user's device like traditional mobile apps.","description":"<h1>React PWA Fundamental</h1><p>A Progressive Web App is a type of web application that combines the best features of web and mobile applications. PWAs can be accessed through a web browser but can also be installed on a user's device like traditional mobile apps. Some key features of PWAs include:</p><ul><li>The ability to work offline</li><li>Fast performance</li><li>Responsive display on various devices</li><li>Access through an icon on the device's home screen</li></ul><p>in this case we will be focused on how to make our react applicaion running on offline, get the requested react module from cache instead from the server. we will be learn about how to cache the customs api fetch that can be store to our react application.</p><h2>What Are Service Workers?</h2><p>Service Workers are a crucial part of PWAs. They are JavaScript files that run in the background and enable features like offline caching, push notifications, and background sync. Service Workers act as intermediaries between your web application and the network, allowing you to control how your PWA behaves in various scenarios.</p><h2>VITE React PWA</h2><p>In Vite React Project, there is some special configuration needed to applied the Progressive Web App. Below is the step-by-step to configure the PWA.</p><h3>Installing vite-plugin-pwa</h3><p>First we need to install the vite-plugin-pwa plugin, just add it to your project as a dev dependency:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">npm install -D vite-plugin-pwa</code></pre><p>Note: to running the implementation of PWA, we need to to build our react vite project, then running the react vite project trough npm run preview. There is some extra configuration to make implementation of PWA running in development mode.</p><h3>Configuring vite-plugin-pwa</h3><p>Edit your vite.config.js / vite.config.ts file and add the vite-plugin-pwa:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { defineConfig } from 'vite'\nimport { VitePWA } from 'vite-plugin-pwa'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    VitePWA({\n      registerType: 'autoUpdate',\n      workbox: {\n        globPatterns: ['**/*.{js,css,html,ico,png,svg}']\n      }\n    })\n  ],\n})</code></pre><h3>Cache External Resources</h3><p>If you have some additional resource like font and css, you must include them into the service workerpre-cache and so your application will work when offline. But in this scenario, we will trying to use some free-api named: https://jsonplaceholder.typicode.com. to fetch the data from it and then stored it to the cache browser. so it can be rendered to a front-end page without the network traffic. The implementation is very easy. we need to addd some property in workbox object named :runtimeCaching. Below the example of how to use it:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"> runtimeCaching: [\n          {\n            urlPattern: ({ url }) =&gt; {\n              return url.pathname.match('/posts/1')\n            },\n            handler: 'CacheFirst',\n            options: {\n              cacheName: 'api-cache',\n              cacheableResponse: {\n                statuses: [0, 200]\n              }\n            }\n          }\n        ]</code></pre><h2>Result Excercise</h2><p>Below is the result example of how the PWA can running the application without the network traffic and requested from the server.</p><img src='https://raw.githubusercontent.com/Barbarpotato/React-PWA-Fundamental/main/git-images/Result.png?token=GHSAT0AAAAAABT2NYLCZWUIB25VOK65BHRIZI6WNAA'/><h2>Service Worker without PWA capabilities</h2><p>Sometimes you don't need the full blown PWA functionality like offline cache and manifest file, but need simple custom Service Worker.</p><h3>Setup the Service Worker</h3><p>You can first check the browsers are supporting the service worker by create the script like below:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">  &lt;script&gt;\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () =&gt; {\n        navigator.serviceWorker.register('/src/serviceWorker.js').then((reg) =&gt; {\n          console.log('Worker Registered!')\n        }).catch(err =&gt; {\n          console.log('Error in service Worker', err)\n        })\n      })\n    }\n  &lt;/script&gt;</code></pre><p>This this code is responsible for registering a service worker for your web application.</p><h2>Offline Caching</h2><p>If the services worker is available (it whill show the Worker Registered in your broswer console). Now let's create the serviceWorker.js file in public directory. We can squeeze the serviceWorker file by create some eventlistener that installed some assests from server to Cache Storage. So the client is not calling the resource from the server anymore instead calling from the client browser cache data.</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">self.addEventListener('install', (event) =&gt; {\n    event.waitUntil(\n        caches.open('PWA-Cache').then((caches) =&gt; {\n            console.log('Opened Cache')\n            return caches.addAll([\n                './assets/react.svg',\n                '/vite.svg'\n            ])\n        })\n    )\n})</code></pre><p>The purpose of this install event handler is to cache these specified assets when the service worker is first installed. Once the assets are cached, they can be served from the cache even if the user is offline, providing offline access to these resources. This is a fundamental step in building Progressive Web Apps (PWAs) that work seamlessly offline.</p><p><br></p><p>After installing all assest from the server to the client. we need to tell the browser that whenever we fetch the data, we need to check the browser cache data first before we calling the server resource. if the client request it is same as the data from a data cache browser, then just use the cache browser data. Below is the example of how the explanation above implemented in javascript:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">self.addEventListener('fetch', (event) =&gt; {\n    event.respondWith(\n        caches.match(event.request).then((response) =&gt; {\n            if (response) {\n                // Cache hit, return the response\n                return response;\n            }\n            // Not found in cache, fetch from the network\n            return fetch(event.request);\n        })\n    );\n});</code></pre>","timestamp":"Friday, September 20, 2024 at 11:37:12 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Freact-pwa.png?alt=media&token=2b264f65-ddf9-4b4a-afa8-efb39cb13c3d","image_alt":"Progressive Web App","slug":"react-pwa-fundamental","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},"recommendedPosts":[{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","timestamp":"2025-03-14 02:46:27","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]},{"blog_id":"911a9001-3c3e-4f2c-aa83-4ec4f6f71c99","title":"Terraform Labs: Automating Google Cloud Infrastructure Deployment","short_description":"Manually managing cloud infrastructure can be time-consuming and error-prone. Terraform changes the game by allowing you to define infrastructure as code, making deployment faster, scalable, and repeatable. With Terraform, you can automate cloud resource creation, track changes, and collaborate effortlessly.","timestamp":"2025-02-15 18:15:22","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739669992396_gcp-terraform.png","image_alt":"Terraform with GCP","slug":"Terraform-Labs-Automating-Google-Cloud-Infrastructure-Deployment","index":"6b86b273ff34f","tags":["Software Architecture","Cloud Computing"]}]},"__N_SSG":true}