{"pageProps":{"article":{"blog_id":"7a76b44a-8bc3-451e-95f0-3ccb1bc23e34","title":"Create Dashboard app with Electron.js","short_description":"In the world of application development, Electron.js has become a popular framework for building desktop applications using web technologies. In this blog, we will discuss how to create a desktop application template with Electron.js using React and Vite as the frontend framework, and IndexedDB as the default client-side database.","description":"<div id=\"content-0\"><h1>What is Electron.js?</h1><p>Electron.js is an open-source framework that allows developers to build cross-platform desktop applications (Windows, macOS, and Linux) using web technologies like HTML, CSS, and JavaScript. Electron combines Chromium and Node.js so that developers can build desktop applications using the same technology they use for web development. I will discussed about the Modash project that i created too. So other people can use this template and ready to be launch as a producition app. This Modash project using the weird stack such as electron.js, React, Vite and IndexDb. i will tell you why i use this stack.</p><p><br></p><h1>Why Use React and Vite?</h1><p>React is a very popular JavaScript library for building user interfaces (UIs). By using React, we can create dynamic and interactive UI components and Vite is a build tool that provides speed and efficiency in frontend project development. Vite offers a fast development experience with hot module replacement (HMR) and a very fast build process.</p><p><br></p><h1>Why IndexedDB?</h1><p>IndexedDB is a web-based database storage solution that provides larger storage compared to LocalStorage and SessionStorage. IndexedDB is ideal for applications that require large data storage on the client side, such as desktop applications built with Electron.js. we can use other database instead of this indexDb in my template. but for a default i used this indexDB to manage my account login. this is not  a good practice because indexDb can be access trough the Web interface and directly clear the dabatase data. but this can be prevent in prouction by blocking the user to inspect the devtools. Here is the code to prevent user inspect and ruined their production app:</p><p><br></p><p><br></p></div><div id=\"content-1\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"> if (process.env.NODE_ENV === \"development\") {\n    win.loadURL(\"http://localhost:6969/\");\n    win.webContents.openDevTools();\n  } else {\n    win.loadFile(path.join(__dirname, \"./dist/index.html\"));\n\n    // Remove the menu (including DevTools shortcuts)\n    win.setMenu(null);\n\n    // Disable context menu (right-click) that might have \"Inspect Element\"\n    win.webContents.on('context-menu', (e) =&gt; {\n      e.preventDefault();\n    });\n\n    // Optionally, prevent any manual attempts to open DevTools\n    win.webContents.on('before-input-event', (event, input) =&gt; {\n      if (input.key === 'I' && input.control && input.shift) {\n        event.preventDefault();\n      }\n    });\n\n    // Make sure DevTools are closed\n    win.webContents.on('did-finish-load', () =&gt; {\n      win.webContents.closeDevTools();\n    });\n  }\n};</code></pre></div><div id=\"content-3\"><p>This code snippet is part of an Electron application setup and handles different behaviors based on whether the application is running in development or production mode. In development mode, it loads the application from a local server (<code>http://localhost:6969/</code>) and opens the Developer Tools for debugging purposes. On the other hand, in production mode, it loads the application from a local HTML file, disables the menu, prevents the context menu from appearing (which might include the \"Inspect Element\" option), and disables the shortcut (<code>Ctrl+Shift+I</code>) for opening the Developer Tools. Additionally, it ensures that the Developer Tools are closed after the application finishes loading, contributing to a cleaner user interface and enhanced security.</p></div><div id=\"content-4\"><h1>Modash</h1><p>This template is used to build the Dashboard application such as inventory list. sales, etc. the default template is using the React router dom for handling and manage the page. the starter kit for css framework i used is a Chakra-UI. You can visit this site to read Chakra-UI docs. <a href=\"https://v2.chakra-ui.com/\" target=\"_blank\">https://v2.chakra-ui.com/</a>. in this template i already built Home page. and the settings page. You can tweak and modify freely as you need if you want to build the dashboard app using this template. Here is the link of my github repository <a href=\"https://github.com/Barbarpotato/Modash\" target=\"_blank\">https://github.com/Barbarpotato/Modash</a>.&nbsp;</p></div><div id=\"content-5\"><h1>Electron Problem with Production</h1><p>Sometimes Electron.js has some trouble to delivered as a production app if you used the electron.js and integrating it wirh React environment. i have face some problems in my journey such as error when production if i sed react-router-dom, etc. to prevent react-router-dom crash during a production, you can use the &lt;HashRouter&gt; instead of &lt;Browser Router&gt;. this will solve the issue in electron production app. Here is the example code:</p></div><div id=\"content-6\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { HashRouter } from 'react-router-dom'\nimport { ChakraProvider } from '@chakra-ui/react'\nimport theme from './theme/theme.js'\nimport App from './App.jsx'\nimport './index.css'\nimport { AuthProvider } from './hooks/useAuth.jsx'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  &lt;ChakraProvider theme={theme}&gt;\n    &lt;HashRouter&gt;\n      &lt;AuthProvider&gt;\n        &lt;App /&gt;\n      &lt;/AuthProvider&gt;\n    &lt;/HashRouter&gt;\n  &lt;/ChakraProvider&gt;\n)</code></pre></div><div id=\"content-7\"><p><code>HashRouter</code> is a type of router provided by React Router DOM, a popular routing library for React applications. The <code>HashRouter</code> uses the hash portion of the URL (the part after the <code>#</code> symbol) to keep the UI in sync with the URL. This makes it suitable for applications that need to be deployed to servers that don't handle dynamic requests, such as GitHub Pages.</p></div><div id=\"content-8\"><h1>Production Mode</h1><p>My Template is very ready about hearing the produciton mode. Dont worry about that. if you not optimis about my template during in production environment. You can clone my repository and attempt to make it as a production app. Go to a terminal and type <strong>npm run prod. </strong>This will make 2 folders name dist and out folder. where the dist folder is the build package for the react and the out folder is the application that you are going to install in your device. Here is the package.json file you can look and learn about the template environment:</p></div><div id=\"content-9\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">{\n  \"name\": \"modash-desktop-app\",\n  \"productName\": \"Modash\",\n  \"description\": \"Modification Dashboard Dekstop App for inventory management purpose\",\n  \"private\": true,\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"electron.cjs\",\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_ENV=development concurrently \\\"npm:serve\\\" \\\"npm:electron\\\"\",\n    \"prod\": \"npm run build && npm run electron-build\",\n    \"serve\": \"vite\",\n    \"build\": \"cross-env NODE_ENV=production vite build\",\n    \"preview\": \"vite preview\",\n    \"electron\": \"wait-on tcp:6969 && electron .\",\n    \"electron-build\": \"cross-env NODE_ENV=production electron-builder\"\n  },\n  \"build\": {\n    \"appId\": \"electron-react-vite\",\n    \"mac\": {\n      \"icon\": \"public/download.ico\"\n    },\n    \"win\": {\n      \"target\": [\n        \"nsis\"\n      ],\n      \"icon\": \"public/download.ico\"\n    },\n    \"nsis\": {\n      \"oneClick\": false,\n      \"allowToChangeInstallationDirectory\": true,\n      \"installerIcon\": \"public/download.ico\",\n      \"uninstallerIcon\": \"public/download.ico\",\n      \"uninstallDisplayName\": \"electron-react-vite\"\n    },\n    \"directories\": {\n      \"output\": \"out\"\n    },\n    \"files\": [\n      \"dist/**/*\",\n      \"electron.cjs\",\n      \"electron/**\"\n    ]\n  },\n  \"dependencies\": {\n    \"@chakra-ui/react\": \"^2.8.2\",\n    \"@emotion/react\": \"^11.11.4\",\n    \"@emotion/styled\": \"^11.11.5\",\n    \"framer-motion\": \"^11.2.6\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-icons\": \"^5.2.1\",\n    \"react-router-dom\": \"^6.23.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.0.28\",\n    \"@types/react-dom\": \"^18.0.11\",\n    \"@vitejs/plugin-react\": \"^4.0.0\",\n    \"builder\": \"^5.0.0\",\n    \"concurrently\": \"^8.0.1\",\n    \"cross-env\": \"^7.0.3\",\n    \"electron\": \"^24.3.1\",\n    \"electron-builder\": \"^24.13.3\",\n    \"eslint\": \"^8.38.0\",\n    \"eslint-plugin-react\": \"^7.32.2\",\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\n    \"eslint-plugin-react-refresh\": \"^0.3.4\",\n    \"vite\": \"^4.3.2\",\n    \"wait-on\": \"^7.0.1\"\n  }\n}</code></pre></div><div id=\"content-10\"><img src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2FModash-Display.png?alt=media&token=3b3d3eef-37e4-4c37-91a1-80394b91069e'/></div><div id=\"content-11\"><p>You need to install your production applicaiton and once installed you can look the first page will display the login page. You can modify this style as you like. but the default style is just like it. Enjoy Use this template and you can build this with fast. and promises production environment ?.</p></div>","timestamp":"Friday, September 20, 2024 at 2:06:27 PM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Felectron.png?alt=media&token=46d654ee-c016-41d2-ab1d-38d5653638a6","image_alt":"Electron.js","slug":"create-dashboard-app-with-electronjs","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},"recommendedPosts":[{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","timestamp":"2025-03-14 02:46:27","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]},{"blog_id":"911a9001-3c3e-4f2c-aa83-4ec4f6f71c99","title":"Terraform Labs: Automating Google Cloud Infrastructure Deployment","short_description":"Manually managing cloud infrastructure can be time-consuming and error-prone. Terraform changes the game by allowing you to define infrastructure as code, making deployment faster, scalable, and repeatable. With Terraform, you can automate cloud resource creation, track changes, and collaborate effortlessly.","timestamp":"2025-02-15 18:15:22","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739669992396_gcp-terraform.png","image_alt":"Terraform with GCP","slug":"Terraform-Labs-Automating-Google-Cloud-Infrastructure-Deployment","index":"6b86b273ff34f","tags":["Software Architecture","Cloud Computing"]}]},"__N_SSG":true}