{"pageProps":{"article":{"blog_id":"978cd40e-18da-47a6-a4fe-917bec69dea1","title":"React Lazy Load","short_description":"React Lazy Load is a technique used to load React components lazily, i.e., only when they are needed. This helps reduce the initial bundle size and improve the performance of your React application. You can easily implement lazy loading in your React project using React.lazy() along with Suspense.","description":"<div id=\"content-0\"><h1><strong>Real-World Case</strong></h1></div><div id=\"content-1\"><img style='width:720px;' src='https://raw.githubusercontent.com/Barbarpotato/React-Lazy-Load/main/git-image/Scenario.png'/></div><div id=\"content-2\"><p>When building a dashboard application. This application has high complexity and requires a large size to be loaded by application users in the future. For example, the dashboard application has several different features, depending on the position of each application user. for example, users with the admin position have a different features in the application compared to users with other positions, for example Sales. When Sales enters a dashboard application. Of course, the features contained in admin will not appear for users with sales positions, BUT users with sales positions will still load the features contained in admin even though they are not used. Vice Versa, This affects the performance, speed and efficiency of an application running.</p><p><br></p><h2><strong>Solution</strong></h2><p>To asnwer the prbolem above, we will be use&nbsp;<code style=\"color: rgb(248, 248, 242); background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">Lazy Load</code>&nbsp;technique, you can optimize the initial loading time and improve the performance of your React application by dynamically loading components as needed.</p><h2><strong>Usage</strong></h2><p>Here are the steps on how to use React Lazy Load in your project:</p><h3><strong>Create the routes for the web page.</strong></h3><p>We have 3 different pags for this case, Main page which can be access for all the role position (Admin, Sales). we have the sales component which can be access by sales person, and the last page is the admin page, where it can only be access by the admin person.</p></div><div id=\"content-3\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { Routes, Route } from 'react-router-dom'\nimport Sales from './pages/Sales'\nimport Home from './pages/Home'\nimport Admin from './pages/Admin'\nimport './App.css'\n\nfunction App() {\n\n  return (\n    &lt;Routes&gt;\n      &lt;Route index element={&lt;Home /&gt;} /&gt;\n      &lt;Route path='/sales' element={&lt;Sales /&gt;} /&gt;\n      &lt;Route path='/admin' element={&lt;Admin /&gt;} /&gt;\n    &lt;/Routes&gt;\n  )\n}\n\nexport default App</code></pre></div><div id=\"content-6\"><p>If we dont implement the lazy load technique&nbsp;&nbsp;our react application&nbsp;it will be load&nbsp;&nbsp;three pages&nbsp;which are Main, Sales&nbsp;&nbsp;the Admin page. If we implement the lazy load, whenever we access the Sales Page, it will be load the Main&nbsp;&nbsp;the Sales Page, Vice Versa</p><h2>Applied the Lazy Load to your React App</h2><p>After build the different page&nbsp;&nbsp;route, we can implement the lazy load by using the lazy&nbsp;&nbsp;Suspense</p></div><div id=\"content-7\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { Routes, Route } from 'react-router-dom'\nimport { lazy, Suspense } from 'react'\nimport Home from './pages/Home'\nimport './App.css'\n\nconst Admin = lazy(() =&gt; import('./pages/Admin'))\nconst Sales = lazy(() =&gt; import('./pages/Sales'))\n\nfunction App() {\n\n  return (\n    &lt;Routes&gt;\n\n      &lt;Route index element={&lt;Home /&gt;} /&gt;\n\n      &lt;Route path='/sales' element={\n        &lt;Suspense fallback={&lt;div&gt;Loading Content...&lt;/div&gt;}&gt;\n          &lt;Sales /&gt;\n        &lt;/Suspense&gt;} /&gt;\n\n      &lt;Route path='/admin' element={\n        &lt;Suspense fallback={&lt;div&gt;Loading Content...&lt;/div&gt;}&gt;\n          &lt;Admin /&gt;\n        &lt;/Suspense&gt;} /&gt;\n\n    &lt;/Routes &gt;\n  )\n}\n\nexport default App</code></pre></div><div id=\"content-8\"><h2><strong>Implementation Result</strong></h2><p>Now, if you go to the Dev Console -&gt; Source. You need to check the page source file. and then check the src folder -&gt; pages . We cannot see our Admin and Sales Component. If we accessing the admin route or the sales route, it will appear in the source dev console. which means that our lazy load implement successfully.</p></div><div id=\"content-10\"><img style='width:720px;' src='https://raw.githubusercontent.com/Barbarpotato/React-Lazy-Load/main/git-image/lazy-load.png'/></div>","timestamp":"Friday, September 20, 2024 at 11:36:59 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Flazy-load.png?alt=media&token=94d1a55f-c578-455a-9623-b561272a9f99","image_alt":"Lazy Load React - Darma","slug":"react-lazy-load","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},"recommendedPosts":[{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","timestamp":"2025-03-14 02:46:27","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]},{"blog_id":"911a9001-3c3e-4f2c-aa83-4ec4f6f71c99","title":"Terraform Labs: Automating Google Cloud Infrastructure Deployment","short_description":"Manually managing cloud infrastructure can be time-consuming and error-prone. Terraform changes the game by allowing you to define infrastructure as code, making deployment faster, scalable, and repeatable. With Terraform, you can automate cloud resource creation, track changes, and collaborate effortlessly.","timestamp":"2025-02-15 18:15:22","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739669992396_gcp-terraform.png","image_alt":"Terraform with GCP","slug":"Terraform-Labs-Automating-Google-Cloud-Infrastructure-Deployment","index":"6b86b273ff34f","tags":["Software Architecture","Cloud Computing"]}]},"__N_SSG":true}